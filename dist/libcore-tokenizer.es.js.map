{"version":3,"file":"libcore-tokenizer.es.js","sources":["../src/regex/state-map.js","../src/regex/tokenizer.js","../src/regex/parser.js","../src/regex/helper.js","../src/regex/fragment.js","../src/regex/pointer.js","../src/regex/state-builder.js","../src/tokenizer.js"],"sourcesContent":["'use strict';\n\nimport {\n            string,\n            number,\n            object\n        } from \"libcore\";\n\nfunction StateMap(start) {\n    var states = {};\n    \n    start = typeof start === 'string' ?\n                            start : 'start';\n    states[start] = {\n        not: []\n    };\n    \n    this.stateGenId = 0;\n    this.start = start;\n    this.states = states;\n    this.ends = {};\n}\n\nStateMap.prototype = {\n    constructor: StateMap,\n    \n    generateState: function (id) {\n        if (string(id)) {\n            return id;\n        }\n        return 's' + (++this.stateGenId);\n    },\n    \n    finalizeFragments: function (name, fragment, endStates) {\n        var states = this.states,\n            ends = this.ends,\n            processed = {},\n            idmap = {},\n            pending = [fragment],\n            pl = 1;\n        var state, stateObject, item, pointer, chr, to, list, l, id,\n            not, tl, targets, total, notIndex;\n        \n        idmap[fragment.state.id] = this.start;\n        \n        for (; pl--;) {\n            item = pending[0];\n            pending.splice(0, 1);\n            \n            state = idmap[item.state.id];\n            if (!(state in states)) {\n                states[state] = {\n                    not: []\n                };\n            }\n            stateObject = states[state];\n            \n            \n            for (pointer = item.pointer; pointer; pointer = pointer.next) {\n                chr = pointer.chr;\n                to = pointer.to;\n                id = to.id;\n                \n                if (!(id in processed)) {\n                    processed[id] = true;\n                    pending[pl++] = to;\n                }\n                \n                // finalize state\n                state = to.state.id;\n                if (!(state in idmap)) {\n                    idmap[state] = this.generateState();\n                }\n                state = idmap[state];\n                \n                // negative\n                if (pointer.negative) {\n                    targets = stateObject.not;\n                    tl = total = targets.length;\n                    \n                    not = null;\n                    for (; tl--;) {\n                        not = targets[tl];\n                        if (not[0] === state) {\n                            break;\n                        }\n                        not = null;\n                    }\n                    \n                    if (!not) {\n                        not = targets[total++] = [state, {}];\n                    }\n                    \n                    notIndex = not[1];\n                    \n                    if (!(chr in notIndex)) {\n                        notIndex[chr] = 1;\n                    }\n                    \n                }\n                // positive\n                else {\n\n                    if (!(chr in stateObject)) {\n                        stateObject[chr] = [];\n                    }\n                    list = stateObject[chr];\n                    if (list.indexOf(state) === -1) {\n                        list[list.length] = state;\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        // create end states\n        for (l = endStates.length; l--;) {\n            ends[idmap[endStates[l]]] = name;\n        }\n\n        \n    },\n    \n    importDefinition: function (json) {\n        var isObject = object,\n            isString = string;\n        var item;\n        \n        if (isString(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                console.warn(e);\n                throw new Error(\"Invalid JSON string parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid JSON object parameter.\");\n        }\n        \n        // verify state gen id\n        item = json.stateGenId;\n        if (!number(item) || item < 0) {\n            throw new Error(\"Invalid state generator\");\n        }\n        this.stateGenId = item;\n        \n        item = json.start;\n        if (!isString(item)) {\n            throw new Error(\"Invalid start state name\");\n        }\n        this.start = item;\n        \n        item = json.states;\n        if (!isObject(item)) {\n            throw new Error(\"Invalid state map object\");\n        }\n        this.states = item;\n        \n        item = json.ends;\n        if (!isObject(item)) {\n            throw new Error(\"Invalid end states object\");\n        }\n        this.ends = item;\n        \n        return this;\n    },\n    \n    exportDefinition: function () {\n        return {\n            stateGenId: this.stateGenId,\n            start: this.start,\n            states: this.states,\n            ends: this.ends\n        };\n    }\n};\n\n\nexport default StateMap;\n","'use strict';\n\nvar HEX_RE = /^[a-fA-F0-9]{2}$/,\n    UTF8_RE = /^[a-fA-F0-9]{4}$/,\n    RANGE_RE = /^([0-9]+|[0-9]+\\,[0-9]*|[0-9]*\\,[0-9]+)$/,\n    SPECIAL_CHAR = {\n        \"b\": \"\\b\",\n        \"f\": \"\\f\",\n        \"n\": \"\\n\",\n        \"r\": \"\\r\",\n        \"t\": \"\\t\",\n        \"v\": \"\\x0B\",\n        \"\\\\\": \"\\\\\",\n        \"B\": \"\\\\\"\n    };\n\nfunction escape(index, regexString) {\n    var c = index + 1,\n        len = c + 1,\n        special = SPECIAL_CHAR,\n        chr = regexString.substring(c, len);\n    var match, l;\n    \n    switch (chr) {\n    case \"x\":\n        l = c + 2;\n        match = regexString.substring(++c, l + 1).match(HEX_RE);\n        \n        return match ?\n                    \n                    [String.\n                        fromCharCode(parseInt(match[0],\n                                                  16)),\n                     l] :\n                    \n                    [\"x\",\n                     len];\n    case \"u\":\n        l = c + 4;\n        match = regexString.substring(++c, l + 1).match(UTF8_RE);\n        \n        return match ?\n                    \n                    [String.\n                        fromCharCode(parseInt(match[0],\n                                                  16)),\n                     l] :\n                    \n                    [\"x\",\n                     len];\n    default:\n        return [chr in special ?\n                    special[chr] : chr,\n                len];\n    }\n}\n\nfunction range(index, regexString) {\n    var c = index,\n        l = regexString.length;\n    var chr;\n    \n    for (; l--;) {\n        chr = regexString.charAt(++c);\n        if (chr === '}') {\n            chr = regexString.substring(index + 1, c);\n            if (RANGE_RE.test(chr)) {\n                return [chr, c + 1];\n            }\n        }\n    }\n    \n    return null;\n    \n}\n\n\nfunction tokenize(index, regexString) {\n    var M = Math,\n        len = regexString.length;\n    var chr, next, token;\n    \n    index = M.max(0, index);\n    \n    if (index > len) {\n        return null;\n    }\n    else if (index === len) {\n        return ['$$', null, len + 1];\n    }\n    \n    next = index + 1;\n    chr = regexString.charAt(index);\n    token =  'char';\n    \n    switch (chr) {\n    case \"\\\\\":\n        chr = escape(index, regexString);\n        next = chr[1];\n        chr = chr[0];\n        token = 'char';\n        break;\n    \n    case \"{\":\n        chr = range(index, regexString);\n        if (chr) {\n            next = chr[1];\n            chr = chr[0];\n            token = 'range';\n        }\n        else {\n            throw new Error(\"Invalid token near \" +\n                        regexString.substring(index,\n                                              M.min(len, index + 10)));\n        }\n        break;\n    \n    case \"[\":\n        if (next < len && regexString.charAt(next) === '^') {\n            token = '[^';\n            next++;\n            break;\n        }\n        \n    /* falls through */\n    case \"]\":\n    case \"(\":\n    case \")\":\n    case \"|\":\n    case \"?\":\n    case \"+\":\n    case \"*\":\n    case \"-\":\n    case \"^\":\n    case \"$\":\n        token = chr;\n        break;\n    }\n    \n    return token ?\n                [token, chr, next] : null;\n}\n\nexport default tokenize;","'use strict';\n\n/**\n * SEQUENCE         -> UNIT\n *                  -> REPEATED\n *                  -> SEQUENCE UNIT\n *                  -> SEQUENCE REPEATED\n *\n * REPEATED         -> UNIT '+'\n *                  -> UNIT '?'\n *                  -> UNIT '*'\n *\n * UNIT             -> 'char'\n *                  -> CLASS\n *                  -> '(' SEQUENCE ')'\n *\n * CLASS            -> '[' CLASS_CHAR ']'\n *\n * CLASS_CHAR       -> CLASS_CHAR CLASS_RANGE\n *                  -> CLASS_RANGE\n *\n * CLASS_RANGE      -> 'char' '-' 'char'\n *                  -> 'char'\n */\n\nimport TOKENIZE from \"./tokenizer.js\";\n        \nvar ENCLOSED_START = 2,\n    ENCLOSED_END = 3,\n    BINARY = 4,\n    POSTFIX = 5,\n    FINAL = 6,\n    OPERATOR = {\n        \"[\": [ENCLOSED_START, 15, \"]\"],\n        \"[^\": [ENCLOSED_START, 15, \"]^\"],\n        \"]\": [ENCLOSED_END, 1, \"[]\"],\n        \"]^\": [ENCLOSED_END, 1, \"[^]\"],\n        \"(\": [ENCLOSED_START, 15, \")\"],\n        \")\": [ENCLOSED_END, 1, \"()\"],\n        \"?\": [POSTFIX, 10],\n        \"+\": [POSTFIX, 10],\n        \"*\": [POSTFIX, 10],\n        \"range\": [POSTFIX, 10],\n        \"-\": [BINARY, 7],\n        \"^-\": [BINARY, 7],\n        \"^,\": [BINARY, 5],\n        \",\": [BINARY, 5],\n        \".\": [BINARY, 5],\n        \"|\": [BINARY, 3],\n        \"$$\": [FINAL, 1]\n    },\n    ENCLOSED_CLASS_REPLACE = {\n        \"[\": 'char',\n        \"[^\": 'char',\n        \"?\": 'char',\n        \"+\": 'char',\n        \"*\": 'char',\n        \",\": 'char',\n        \"|\": 'char',\n        \"(\": 'char',\n        \")\": 'char'\n    },\n    ENCLOSED_REPLACE = {\n        \"[\": ENCLOSED_CLASS_REPLACE,\n        \"[^\": ENCLOSED_CLASS_REPLACE,\n        \"(\": {\n            \"-\": 'char'\n        }\n    };\n\nexport\n    function parse(str) {\n        var operator = OPERATOR,\n            tokenize = TOKENIZE,\n            enclosed_start = ENCLOSED_START,\n            enclosed_end = ENCLOSED_END,\n            binary = BINARY,\n            postfix = POSTFIX,\n            end = FINAL,\n            index = 0,\n            start = 0,\n            stack = null,\n            queue = [],\n            ql = 0,\n            lastToken = null,\n            enclosure = [null, '('],\n            enclosedReplacements = ENCLOSED_REPLACE,\n            buffer = [],\n            bl = 0,\n            bc = 0;\n            \n        var token, chr, item, l, op, stackOp, precedence,\n            fill, opName, from, currentEnclosure, replacements;\n        \n        for (item = tokenize(index, str); item; item = tokenize(index, str))  {\n            index = item[2];\n            chr = item[1];\n            token = item[0];\n            fill = false;\n            currentEnclosure = enclosure && enclosure[1];\n            \n            // replace token based on replacement by enclosure\n            if (currentEnclosure) {\n                replacements = enclosedReplacements[currentEnclosure];\n                if (token in replacements) {\n                    token = replacements[token];\n                }\n            }\n            \n            // finalize and fill-in concat operator\n            if (token in operator) {\n                switch (token) {\n                case '(':\n                case '[':\n                case '[^':\n                    // fill if there's lastToken and not \"|\"\n                    fill = !!lastToken && lastToken !== '|';\n                }\n            }\n            else {\n                switch (lastToken) {\n                case 'negative_char':\n                case 'char':\n                case ']':\n                case ']^':\n                case ')':\n                case '+':\n                case '?':\n                case '*':\n                case 'range':\n                    fill = true;\n                }\n            }\n            \n            if (fill) {\n                buffer[bl++] = [currentEnclosure === '[' ?\n                                    ',' :\n                                    currentEnclosure === '[^' ?\n                                        '^,' :\n                                        '.',\n                                null,\n                                2,\n                                start,\n                                0];\n            }\n            \n            if (currentEnclosure === '[^') {\n                switch (token) {\n                case '-':\n                    token = '^-';\n                    break;\n                \n                case ']':\n                    token = ']^';\n                    break;\n                \n                case 'char':\n                    token = 'negative_char';\n                }\n            }\n            \n            buffer[bl++] = [token, chr, 0, start, index - start];\n            start = index;\n            lastToken = token;\n            \n            // parse buffer\n            l = bl - bc;\n            for (; l--; bc++) {\n                item = buffer[bc];\n                token = item[0];\n                chr = item[1];\n                \n                if (token in operator) {\n                    op = operator[token];\n                    opName = op[0];\n                    precedence = op[1];\n\n                    \n                    switch (opName) {\n                    case end:\n                    case postfix:\n                    case binary:\n                        \n                        item[2] = opName === binary ? 2 : 1;\n                        \n                        binaryCompare: for (; stack; stack = stack[0]) {\n                            stackOp = stack[1];\n                            switch (stackOp[0]) {\n                            case postfix:\n                            case binary:\n                                \n                                if (precedence <= stackOp[1]) {\n                                    queue[ql++] = stack[2];\n                                    continue binaryCompare;\n                                }\n                            \n                            }\n                            break binaryCompare;\n                        }\n                        \n                        if (opName !== end) {\n                            stack = [stack, op, item];\n                        }\n                        else {\n                            queue[ql++] = item;\n                        }\n                        break;\n                        \n                    case enclosed_start:\n                        stack = [stack, op, item];\n                        enclosure = [enclosure, token];\n                        break;\n                    \n                    case enclosed_end:\n                        \n                        for (; stack; stack = stack[0]) {\n                            stackOp = stack[1];\n                            \n                            if (stackOp[0] === enclosed_start) {\n                                if (stackOp[2] !== token) {\n                                    throw new Error(\"Unmatched token found \" + chr);\n                                }\n                                from = stack[2][3];\n                                queue[ql++] = [op[2],\n                                               null,\n                                               1,\n                                               from,\n                                               item[3] - from + 1];\n                                if (enclosure) {\n                                    enclosure = enclosure[0];\n                                }\n                                stack = stack[0];\n                                break;\n                            }\n                            \n                            queue[ql++] = stack[2];\n                        }\n                    }\n                }\n                else {\n                    queue[ql++] = item;\n                }\n            }\n        }\n    \n        // there are unmatched or invalid token pending from stack\n        if (stack) {\n            throw new Error(\"Invalid token found \" + stack[2][1]);\n        }\n        \n        return queue;\n    \n    }\n\nexport default parse;","'use strict';\n\nfunction empty() {}\n\nexport\n    function clone(instance) {\n        empty.prototype = instance;\n        return new empty();\n    }\n","'use strict';\n\nimport { clone } from \"./helper.js\";\n\n\nfunction Fragment(builder, pointer) {\n    this.id = 'f' + (++builder.fgen);\n    this.state = { id: null };\n    this.builder = builder;\n    \n    if (pointer) {\n        \n        this.pointer = pointer;\n        \n        for (; pointer.next; pointer = pointer.next) {}\n        this.lastPointer = pointer;\n        \n        // create outgoing\n        this.outgoing = this.lastOutgoing = {\n            fragment: this,\n            next: null\n        };\n        \n    }\n    \n    \n}\n\nFragment.prototype = {\n    constructor: Fragment,\n    id: null,\n    state: null,\n    base: null,\n    map: null,\n    splitted: null,\n    repeated: null,\n    pointer: null,\n    lastPointer: null,\n    outgoing: null,\n    lastOutgoing: null,\n    \n    link: function (operand2) {\n        var operand1 = this,\n            outgoing = operand1.outgoing,\n            split = operand1.splitted,\n            newSplit = operand2.splitted,\n            repeat = operand1.repeated;\n        var clone, last, fragment, pointer, startSplit, endSplit, created;\n        \n        operand2.applyState();\n        \n        for (; outgoing; outgoing = outgoing.next) {\n            outgoing.fragment.pointer.point(operand2);\n        }\n        \n        // repeat\n        if (repeat) {\n            last = operand2.lastPointer;\n            \n            for (; repeat; repeat = repeat.next) {\n                clone = repeat.pointer;\n                \n                if (!last) {\n                    operand2.pointer = clone;\n                }\n                else {\n                    last.next = clone;\n                }\n                \n                last = clone;\n                \n            }\n            \n            operand2.lastPointer = last;\n        }\n        \n        // split and not end state\n        pointer = operand2.pointer;\n        if (split && pointer) {\n            \n            startSplit = endSplit = null;\n            \n            // not end state\n            for (; split; split = split.next) {\n                fragment = split.fragment;\n                clone = pointer.clone();\n                last = fragment.lastPointer.last();\n                last.next = clone[0];\n                fragment.lastPointer = clone[1];\n                \n                // include split to next\n                if (fragment.pointer !== operand1.pointer) {\n                    created = {\n                        fragment: fragment,\n                        next: null\n                    };\n                    \n                    if (!startSplit) {\n                        startSplit = created;\n                    }\n                    else {\n                        endSplit.next = created;\n                    }\n                    \n                    endSplit = created;\n                }\n            }\n            \n            // concatenate split\n            if (endSplit) {\n                endSplit.next = newSplit;\n                newSplit = startSplit;\n            }\n\n        }\n        \n        // apply repeat to all splits?\n        \n        fragment = operand1.clone();\n        fragment.splitted = newSplit;\n        fragment.repeated = operand2.repeated;\n        \n        fragment.outgoing = operand2.outgoing;\n        fragment.lastOutgoing = operand2.lastOutgoing;\n        \n        return fragment;\n    },\n    \n    lastSplit: function () {\n        var split = this.splitted;\n        if (split) {\n            for (; split.next; split = split.next) {}\n            return split;\n        }\n        return null;\n        \n    },\n    \n    clone: function () {\n        var base = this.base,\n            cloned = clone(this);\n        \n        if (!base) {\n            cloned.base = this;\n        }\n        \n        cloned.id = 'f' + (++this.builder.fgen);\n        return cloned;\n    },\n    \n    split: function (repeat) {\n        var me = this,\n            current = me.splitted,\n            split = {\n                fragment: me,\n                next: null\n            },\n            fragment = me.clone();\n            \n        if (repeat) {\n            fragment.repeat();\n        }\n        \n        if (!current) {\n            fragment.splitted = split;\n        }\n        \n        return fragment;\n        \n    },\n    \n    repeat: function () {\n        var fragment = this,\n            pointer = fragment.pointer,\n            current = fragment.repeated;\n            \n        if (!current && pointer) {\n            pointer = pointer.clone();\n            \n            fragment.repeated = {\n                pointer: pointer[0],\n                next: null\n            };\n        }\n        \n        return fragment;\n    },\n    \n    fill: function (operand2) {\n        var operand1 = this,\n            range = operand1.pointer.range(operand2.pointer);\n        var fragment;\n            \n        if (range) {\n            \n            // set 2nd operand state id\n            operand2.state = operand1.state;\n            \n            // connect pointers\n            if (range) {\n                range[1].next = operand2.pointer;\n            }\n            else {\n                range = [operand2.pointer];\n            }\n            \n            operand1.lastPointer.next = range[0];\n            \n            fragment = operand1.clone();\n            fragment.lastPointer = operand2.lastPointer;\n            \n            // merge outgoing\n            fragment.outgoing.next = operand2.outgoing;\n            fragment.lastOutgoing = operand2.lastOutgoing;\n            \n            return fragment;\n        }\n        \n        // merge\n        return this.merge(operand2);\n    },\n    \n    merge: function (operand2) {\n        var operand1 = this,\n            fragment = operand1.clone();\n        var last, first, item;\n        \n        // apply state if operand1 has state\n        \n        // merge state\n        operand2.state = operand1.state;\n        \n        operand1.lastPointer.next = operand2.pointer;\n        operand1.lastOutgoing.next = operand2.outgoing;\n        \n        fragment.lastPointer = operand2.lastPointer;\n        fragment.lastOutgoing = operand2.lastOutgoing;\n        \n        // create split\n        first = operand1.splitted;\n        last = operand2.splitted;\n        fragment.splitted = first || last;\n        \n        if (first && last) {\n            for (item = first; item.next; item = item.next) { }\n            item.next = last;\n        }\n        \n        // create repeat\n        first = operand1.repeated;\n        last = operand2.repeated;\n        fragment.repeated = first || last;\n        \n        if (first && last) {\n            for (item = first; item.next; item = item.next) { }\n            item.next = last;\n        }\n        \n        \n        \n        return fragment;\n    },\n    \n    applyState: function () {\n        var state = this.state;\n        \n        if (!state.id) {\n            state.id = 's' + (++this.builder.gen);\n        }\n        \n        return state;\n    }\n    \n};\n\nexport default Fragment;\n","'use strict';\n\nimport {\n            assign\n        } from \"libcore\";\n        \nimport { clone } from \"./helper.js\";\n\n\nfunction Pointer(chr, negative) {\n    if (chr) {\n        this.chr = chr;\n    }\n    \n    this.negative = negative === true;\n}\n\nPointer.prototype = {\n    constructor: Pointer,\n    negative: false,\n    repeated: false,\n    chr: '',\n    to: null,\n    next: null,\n    \n    clone: function (overrides) {\n        var pointer = this,\n            from = null,\n            dupe = clone,\n            apply = assign,\n            includeNext = overrides !== false;\n        var created, last;\n        \n        if (!overrides) {\n            overrides = null;\n        }\n        \n        for (; pointer; pointer = pointer.next) {\n            created = dupe(pointer);\n            if (overrides) {\n                apply(created, overrides);\n            }\n            \n            if (from) {\n                last.next = created;\n            }\n            else {\n                from = created;\n            }\n            \n            last = created;\n            if (!includeNext) {\n                break;\n            }\n        }\n        \n        last.next = null;\n        \n        return [from, last];\n        \n    },\n    \n    point: function (fragment) {\n        var pointer = this;\n        \n        for (; pointer; pointer = pointer.next) {\n            if (!pointer.to) {\n                pointer.to = fragment;\n            }\n        }\n        \n        return this;\n    },\n    \n    last: function () {\n        var pointer = this;\n        \n        for (; pointer.next; pointer = pointer.next) {}\n        \n        return pointer;\n    },\n    \n    range: function (to) {\n        var chr = this.chr,\n            Class = Pointer,\n            S = String,\n            start = null,\n            end = null,\n            negative = this.negative;\n        var from, len, created;\n        \n        from = chr.charCodeAt(0);\n        chr = to.chr;\n        to = chr.charCodeAt(0);\n        len = Math.max(to - from - 1, 0);\n        \n        if (len) {\n            for (; len--;) {\n                created = new Class(S.fromCharCode(++from), negative);\n                if (start) {\n                    end.next = created;\n                }\n                else {\n                    start = created;\n                }\n                end = created;\n            }\n            \n            return start && [start, end];\n        \n        }\n        \n        return null;\n        \n    }\n    \n};\n\nexport default Pointer;","'use strict';\n\nimport parse from \"./parser.js\";\n\nimport StateMap from \"./state-map.js\";\n\nimport Fragment from \"./fragment.js\";\n\nimport Pointer from \"./pointer.js\";\n\nvar PATTERN_ERROR = 'Patterns resulting to empty token is not allowed. ';\n\nfunction build(name, regex, stateObject) {\n    \n    var F = Fragment,\n        P = Pointer,\n        rpn = parse(regex),\n        c = -1,\n        l = rpn.length,\n        stack = null,\n        startState = null,\n        el = 0,\n        endStates = [],\n        errorName = name + ' = /' + regex + '/',\n        builder = {\n            gen: 0,\n            fgen: 0\n        };\n        \n    var item, token, split, operand1, operand2, id, sid;\n        \n    if (!(stateObject instanceof StateMap)) {\n        stateObject = new StateMap();\n    }\n\n    for (; l--;) {\n        item = rpn[++c];\n        token = item[0];\n        \n        switch (token) {\n        // concat\n        case '.':\n            stack = [stack[0][0],\n                        stack[0][1].link(stack[1])];\n            break;\n        \n        // one or none\n        case '?':\n            stack = [stack[0],\n                        stack[1].split()];\n            break;\n        \n        // repeat one or more\n        case '+':\n            stack = [stack[0],\n                        stack[1].repeat()];\n            break;\n        \n        // repeat none or more (kleen star)\n        case '*':\n            stack = [stack[0],\n                        stack[1].split(true)];\n            break;\n        \n        // character class concat\n        case '^,':\n        case ',':\n        case '|': // also applicable to alternative\n            stack = [stack[0][0],\n                        stack[0][1].merge(stack[1],\n                                          token === '^,')];\n            break;\n        \n        // character class range\n        case '^-':\n        case '-':\n            stack = [stack[0][0],\n                        stack[0][1].fill(stack[1],\n                                         token === '^-')];\n            break;\n        \n        case '$$':\n            if (!stack || stack[0] !== null) {\n                console.warn(stack);\n                throw new Error(\"Invalid end of expression. \" + errorName);\n            }\n            \n            operand1 = stack[1];\n            operand2 = new F(builder, null);\n            operand1.link(operand2);\n            \n            sid = startState.id;\n            id = operand2.state.id;\n            \n            if (id === sid) {\n                throw new Error(PATTERN_ERROR + errorName);\n            }\n            \n            endStates[el++] = id;\n            \n            // end split fragments\n            split = operand1.splitted;\n            \n            for (; split; split = split.next) {\n                id = split.fragment.state.id;\n                if (id === sid) {\n                    throw new Error(PATTERN_ERROR + errorName);\n                }\n                endStates[el++] = id;\n                //if (id !== sid) {\n                //    console.log(regex);\n                //    endStates[el++] = id;\n                //}\n            }\n            break;\n        \n        case '^':\n        case '$':\n        case 'char':\n        case 'negative_char':\n            operand1 = new F(builder,\n                             new P(item[1], token === 'negative_char'));\n            \n            if (!startState) {\n                startState = operand1.applyState();\n            }\n\n            stack = [stack, operand1];\n            \n            \n\n        }\n        \n    }\n    \n    \n    if (el) {\n        stateObject.finalizeFragments(name, stack[1], endStates);\n    }\n    \n    builder = stack = split = operand1 = operand2 = null;\n    \n    return stateObject;\n    \n}\n\nexport default build;","'use strict';\n\nimport {\n            string,\n            regex,\n            array\n        } from \"libcore\";\n\nimport StateMap from \"./regex/state-map.js\";\n\nimport builder from \"./regex/state-builder.js\";\n\nfunction Tokenizer() {\n    this.map = new StateMap();\n}\n\nTokenizer.prototype = {\n    map: null,\n    constructor: Tokenizer,\n    \n    define: function (definitions) {\n        var isString = string,\n            isRegex = regex,\n            map = this.map,\n            build = builder,\n            name = null;\n        var item, c, len;\n        \n        if (!array(definitions)) {\n            throw new Error(\"Invalid definitions parameter.\");\n        }\n        \n        c = -1;\n        len = definitions.length;\n        \n        for (; len--;) {\n            item = definitions[++c];\n            \n            if (isString(item)) {\n                name = item;\n                \n            }\n            else if (isRegex(item)) {\n                item = item.source;\n                if (!name) {\n                    throw new Error(\"Token is not named \" + item);\n                }\n                \n                build(name, item, map);\n                \n            }\n            \n        }\n        \n        return this;\n    },\n    \n    fromJSON: function (data) {\n        this.map.importDefinition(data);\n        return this;\n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        return this.map.exportDefinition();\n    },\n    \n    tokenize: function (from, str) {\n        var map = this.map,\n            ends = map.ends,\n            states = map.states,\n            cursor = [map.start, null],\n            len = str.length,\n            limit = len - from,\n            index = from - 1,\n            found = null;\n        var chr, c, l, next, list, state, pointer, target, not, nmap;\n        \n        if (limit === 0) {\n            return ['$', '', len + 1];\n        }\n        else if (limit < 1) {\n            return null;\n        }\n        \n        for (; limit--;) {\n            chr = str.charAt(++index);\n            next = null;\n            for (; cursor; cursor = cursor[1]) {\n                state = cursor[0];\n                pointer = states[state];\n                \n                if (state in ends) {\n                    found = [ends[state], index];\n                }\n                \n                // apply positive match\n                if (chr in pointer) {\n                    list = pointer[chr];\n                    \n                    \n                    for (c = -1, l = list.length; l--;) {\n                        target = list[++c];\n                        next = [target, next];\n                        \n                        //console.log(state,':', chr, '->', target);\n                        \n                        // found token\n                        if (target in ends) {\n                            found = [ends[target], index + 1];\n                        }\n                    }\n                }\n                \n                // find negative match\n                not = pointer.not;\n                for (c = -1, l = not.length; l--;) {\n                    target = not[++c];\n                    nmap = target[1];\n                    \n                    if (!(chr in nmap)) {\n                        target = target[0];\n                        next = [target, next];\n                        //console.log(state,':', chr, '->', target);\n                        \n                        // found token\n                        if (target in ends) {\n                            found = [ends[target], index + 1];\n                        }\n                    }\n                }\n\n            }\n            \n            if (next) {\n                cursor = next;\n            }\n            else {\n                break;\n            }\n            \n        }\n        \n        \n        \n        if (found) {\n            \n            index = found[1];\n            \n            // nothing was parsed\n            if (from === index) {\n                found = null;\n            }\n            else {\n                found[2] = index;\n                found[1] = str.substring(from, index);\n            }\n        }\n        \n        return found;\n        \n    }\n};\n\n\nexport default Tokenizer;\n"],"names":["this","tokenize","TOKENIZE","clone","regex","Tokenizer","build","builder"],"mappings":"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"}