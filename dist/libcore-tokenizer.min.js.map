{"version":3,"file":"libcore-tokenizer.min.js","sources":["../src/regex/state-map.js","../src/regex/tokenizer.js","../src/regex/parser.js","../src/regex/helper.js","../src/regex/fragment.js","../src/regex/pointer.js","../src/regex/state-builder.js","../src/tokenizer.js"],"sourcesContent":["'use strict';\n\nimport {\n            string,\n            number,\n            object,\n            array\n        } from \"libcore\";\n\nfunction StateMap(start) {\n    var states = {};\n    \n    start = typeof start === 'string' ?\n                            start : 'start';\n    states[start] = {\n        not: []\n    };\n    \n    this.priority = [];\n    this.stateGenId = 0;\n    this.start = start;\n    this.states = states;\n    this.ends = {};\n}\n\nStateMap.prototype = {\n    constructor: StateMap,\n    \n    generateState: function (id) {\n        if (string(id)) {\n            return id;\n        }\n        return 's' + (++this.stateGenId);\n    },\n    \n    finalizeFragments: function (name, fragment, endStates) {\n        var states = this.states,\n            ends = this.ends,\n            processed = {},\n            idmap = {},\n            pending = [fragment],\n            pl = 1;\n        var state, stateObject, item, pointer, chr, to, list, l, id,\n            not, tl, targets, total, notIndex, endList, endIndex;\n        \n        idmap[fragment.state.id] = this.start;\n        \n        for (; pl--;) {\n            item = pending[0];\n            pending.splice(0, 1);\n            \n            state = idmap[item.state.id];\n            if (!(state in states)) {\n                states[state] = {\n                    not: []\n                };\n            }\n            stateObject = states[state];\n            \n            \n            for (pointer = item.pointer; pointer; pointer = pointer.next) {\n                chr = pointer.chr;\n                to = pointer.to;\n                id = to.id;\n                \n                if (!(id in processed)) {\n                    processed[id] = true;\n                    pending[pl++] = to;\n                }\n                \n                // finalize state\n                state = to.state.id;\n                if (!(state in idmap)) {\n                    idmap[state] = this.generateState();\n                }\n                state = idmap[state];\n                \n                // negative\n                if (pointer.negative) {\n                    targets = stateObject.not;\n                    tl = total = targets.length;\n                    \n                    not = null;\n                    for (; tl--;) {\n                        not = targets[tl];\n                        if (not[0] === state) {\n                            break;\n                        }\n                        not = null;\n                    }\n                    \n                    if (!not) {\n                        not = targets[total++] = [state, {}];\n                    }\n                    \n                    notIndex = not[1];\n                    \n                    if (!(chr in notIndex)) {\n                        notIndex[chr] = 1;\n                    }\n                    \n                }\n                // positive\n                else {\n\n                    if (!(chr in stateObject)) {\n                        stateObject[chr] = [];\n                    }\n                    list = stateObject[chr];\n                    if (list.indexOf(state) === -1) {\n                        list[list.length] = state;\n                    }\n                    \n                }\n            }\n            \n        }\n        \n        // create end states\n        for (l = endStates.length; l--;) {\n            // fixing race ends\n            ends[idmap[endStates[l]]] = name;\n        }\n\n        \n    },\n    \n    importDefinition: function (json) {\n        var isObject = object,\n            isString = string;\n        var item;\n        \n        if (isString(json)) {\n            try {\n                json = JSON.parse(json);\n            }\n            catch (e) {\n                console.warn(e);\n                throw new Error(\"Invalid JSON string parameter.\");\n            }\n        }\n        \n        if (!isObject(json)) {\n            throw new Error(\"Invalid JSON object parameter.\");\n        }\n        \n        // verify state gen id\n        item = json.stateGenId;\n        if (!number(item) || item < 0) {\n            throw new Error(\"Invalid state generator\");\n        }\n        this.stateGenId = item;\n        \n        item = json.start;\n        if (!isString(item)) {\n            throw new Error(\"Invalid start state name\");\n        }\n        this.start = item;\n        \n        item = json.states;\n        if (!isObject(item)) {\n            throw new Error(\"Invalid state map object\");\n        }\n        this.states = item;\n        \n        item = json.ends;\n        if (!isObject(item)) {\n            throw new Error(\"Invalid end states object\");\n        }\n\n        item = json.priority;\n        if (!array(item)) {\n            throw new Error(\"Invalid priority list\");\n        }\n        this.priority = item;\n\n        this.ends = item;\n        \n        return this;\n    },\n    \n    exportDefinition: function () {\n        return {\n            stateGenId: this.stateGenId,\n            start: this.start,\n            states: this.states,\n            ends: this.ends,\n            priority: this.priority\n        };\n    }\n};\n\n\nexport default StateMap;\n","'use strict';\n\nvar HEX_RE = /^[a-fA-F0-9]{2}$/,\n    UTF8_RE = /^[a-fA-F0-9]{4}$/,\n    RANGE_RE = /^([0-9]+|[0-9]+\\,[0-9]*|[0-9]*\\,[0-9]+)$/,\n    SPECIAL_CHAR = {\n        \"b\": \"\\b\",\n        \"f\": \"\\f\",\n        \"n\": \"\\n\",\n        \"r\": \"\\r\",\n        \"t\": \"\\t\",\n        \"v\": \"\\x0B\",\n        \"\\\\\": \"\\\\\",\n        \"B\": \"\\\\\"\n    };\n\nfunction escape(index, regexString) {\n    var c = index + 1,\n        len = c + 1,\n        special = SPECIAL_CHAR,\n        chr = regexString.substring(c, len);\n    var match, l;\n    \n    switch (chr) {\n    case \"x\":\n        l = c + 2;\n        match = regexString.substring(++c, l + 1).match(HEX_RE);\n        \n        return match ?\n                    \n                    [String.\n                        fromCharCode(parseInt(match[0],\n                                                  16)),\n                     l] :\n                    \n                    [\"x\",\n                     len];\n    case \"u\":\n        l = c + 4;\n        match = regexString.substring(++c, l + 1).match(UTF8_RE);\n        \n        return match ?\n                    \n                    [String.\n                        fromCharCode(parseInt(match[0],\n                                                  16)),\n                     l] :\n                    \n                    [\"x\",\n                     len];\n    default:\n        return [chr in special ?\n                    special[chr] : chr,\n                len];\n    }\n}\n\nfunction range(index, regexString) {\n    var c = index,\n        l = regexString.length;\n    var chr;\n    \n    for (; l--;) {\n        chr = regexString.charAt(++c);\n        if (chr === '}') {\n            chr = regexString.substring(index + 1, c);\n            if (RANGE_RE.test(chr)) {\n                return [chr, c + 1];\n            }\n        }\n    }\n    \n    return null;\n    \n}\n\n\nfunction tokenize(index, regexString) {\n    var M = Math,\n        len = regexString.length;\n    var chr, next, token;\n    \n    index = M.max(0, index);\n    \n    if (index > len) {\n        return null;\n    }\n    else if (index === len) {\n        return ['$$', null, len + 1];\n    }\n    \n    next = index + 1;\n    chr = regexString.charAt(index);\n    token =  'char';\n    \n    switch (chr) {\n    case \"\\\\\":\n        chr = escape(index, regexString);\n        next = chr[1];\n        chr = chr[0];\n        token = 'char';\n        break;\n    \n    case \"{\":\n        chr = range(index, regexString);\n        if (chr) {\n            next = chr[1];\n            chr = chr[0];\n            token = 'range';\n        }\n        else {\n            throw new Error(\"Invalid token near \" +\n                        regexString.substring(index,\n                                              M.min(len, index + 10)));\n        }\n        break;\n    \n    case \"[\":\n        if (next < len && regexString.charAt(next) === '^') {\n            token = '[^';\n            next++;\n            break;\n        }\n        \n    /* falls through */\n    case \"]\":\n    case \"(\":\n    case \")\":\n    case \"|\":\n    case \"?\":\n    case \"+\":\n    case \"*\":\n    case \"-\":\n    case \"^\":\n    case \"$\":\n        token = chr;\n        break;\n    }\n    \n    return token ?\n                [token, chr, next] : null;\n}\n\nexport default tokenize;","'use strict';\n\n/**\n * SEQUENCE         -> UNIT\n *                  -> REPEATED\n *                  -> SEQUENCE UNIT\n *                  -> SEQUENCE REPEATED\n *\n * REPEATED         -> UNIT '+'\n *                  -> UNIT '?'\n *                  -> UNIT '*'\n *\n * UNIT             -> 'char'\n *                  -> CLASS\n *                  -> '(' SEQUENCE ')'\n *\n * CLASS            -> '[' CLASS_CHAR ']'\n *\n * CLASS_CHAR       -> CLASS_CHAR CLASS_RANGE\n *                  -> CLASS_RANGE\n *\n * CLASS_RANGE      -> 'char' '-' 'char'\n *                  -> 'char'\n */\n\nimport TOKENIZE from \"./tokenizer.js\";\n        \nvar ENCLOSED_START = 2,\n    ENCLOSED_END = 3,\n    BINARY = 4,\n    POSTFIX = 5,\n    FINAL = 6,\n    OPERATOR = {\n        \"[\": [ENCLOSED_START, 15, \"]\"],\n        \"[^\": [ENCLOSED_START, 15, \"]^\"],\n        \"]\": [ENCLOSED_END, 1, \"[]\"],\n        \"]^\": [ENCLOSED_END, 1, \"[^]\"],\n        \"(\": [ENCLOSED_START, 15, \")\"],\n        \")\": [ENCLOSED_END, 1, \"()\"],\n        \"?\": [POSTFIX, 10],\n        \"+\": [POSTFIX, 10],\n        \"*\": [POSTFIX, 10],\n        \"range\": [POSTFIX, 10],\n        \"-\": [BINARY, 7],\n        \"^-\": [BINARY, 7],\n        \"^,\": [BINARY, 5],\n        \",\": [BINARY, 5],\n        \".\": [BINARY, 5],\n        \"|\": [BINARY, 3],\n        \"$$\": [FINAL, 1]\n    },\n    ENCLOSED_CLASS_REPLACE = {\n        \"[\": 'char',\n        \"[^\": 'char',\n        \"?\": 'char',\n        \"+\": 'char',\n        \"*\": 'char',\n        \",\": 'char',\n        \"|\": 'char',\n        \"(\": 'char',\n        \")\": 'char'\n    },\n    ENCLOSED_REPLACE = {\n        \"[\": ENCLOSED_CLASS_REPLACE,\n        \"[^\": ENCLOSED_CLASS_REPLACE,\n        \"(\": {\n            \"-\": 'char'\n        }\n    };\n\nexport\n    function parse(str) {\n        var operator = OPERATOR,\n            tokenize = TOKENIZE,\n            enclosed_start = ENCLOSED_START,\n            enclosed_end = ENCLOSED_END,\n            binary = BINARY,\n            postfix = POSTFIX,\n            end = FINAL,\n            index = 0,\n            start = 0,\n            stack = null,\n            queue = [],\n            ql = 0,\n            lastToken = null,\n            enclosure = [null, '('],\n            enclosedReplacements = ENCLOSED_REPLACE,\n            buffer = [],\n            bl = 0,\n            bc = 0;\n            \n        var token, chr, item, l, op, stackOp, precedence,\n            fill, opName, from, currentEnclosure, replacements;\n        \n        for (item = tokenize(index, str); item; item = tokenize(index, str))  {\n            index = item[2];\n            chr = item[1];\n            token = item[0];\n            fill = false;\n            currentEnclosure = enclosure && enclosure[1];\n            \n            // replace token based on replacement by enclosure\n            if (currentEnclosure) {\n                replacements = enclosedReplacements[currentEnclosure];\n                if (token in replacements) {\n                    token = replacements[token];\n                }\n            }\n            \n            // finalize and fill-in concat operator\n            if (token in operator) {\n                switch (token) {\n                case '(':\n                case '[':\n                case '[^':\n                    // fill if there's lastToken and not \"|\"\n                    fill = !!lastToken && lastToken !== '|';\n                }\n            }\n            else {\n                switch (lastToken) {\n                case 'negative_char':\n                case 'char':\n                case ']':\n                case ']^':\n                case ')':\n                case '+':\n                case '?':\n                case '*':\n                case 'range':\n                    fill = true;\n                }\n            }\n            \n            if (fill) {\n                buffer[bl++] = [currentEnclosure === '[' ?\n                                    ',' :\n                                    currentEnclosure === '[^' ?\n                                        '^,' :\n                                        '.',\n                                null,\n                                2,\n                                start,\n                                0];\n            }\n            \n            if (currentEnclosure === '[^') {\n                switch (token) {\n                case '-':\n                    token = '^-';\n                    break;\n                \n                case ']':\n                    token = ']^';\n                    break;\n                \n                case 'char':\n                    token = 'negative_char';\n                }\n            }\n            \n            buffer[bl++] = [token, chr, 0, start, index - start];\n            start = index;\n            lastToken = token;\n            \n            // parse buffer\n            l = bl - bc;\n            for (; l--; bc++) {\n                item = buffer[bc];\n                token = item[0];\n                chr = item[1];\n                \n                if (token in operator) {\n                    op = operator[token];\n                    opName = op[0];\n                    precedence = op[1];\n\n                    \n                    switch (opName) {\n                    case end:\n                    case postfix:\n                    case binary:\n                        \n                        item[2] = opName === binary ? 2 : 1;\n                        \n                        binaryCompare: for (; stack; stack = stack[0]) {\n                            stackOp = stack[1];\n                            switch (stackOp[0]) {\n                            case postfix:\n                            case binary:\n                                \n                                if (precedence <= stackOp[1]) {\n                                    queue[ql++] = stack[2];\n                                    continue binaryCompare;\n                                }\n                            \n                            }\n                            break binaryCompare;\n                        }\n                        \n                        if (opName !== end) {\n                            stack = [stack, op, item];\n                        }\n                        else {\n                            queue[ql++] = item;\n                        }\n                        break;\n                        \n                    case enclosed_start:\n                        stack = [stack, op, item];\n                        enclosure = [enclosure, token];\n                        break;\n                    \n                    case enclosed_end:\n                        \n                        for (; stack; stack = stack[0]) {\n                            stackOp = stack[1];\n                            \n                            if (stackOp[0] === enclosed_start) {\n                                if (stackOp[2] !== token) {\n                                    throw new Error(\"Unmatched token found \" + chr);\n                                }\n                                from = stack[2][3];\n                                queue[ql++] = [op[2],\n                                               null,\n                                               1,\n                                               from,\n                                               item[3] - from + 1];\n                                if (enclosure) {\n                                    enclosure = enclosure[0];\n                                }\n                                stack = stack[0];\n                                break;\n                            }\n                            \n                            queue[ql++] = stack[2];\n                        }\n                    }\n                }\n                else {\n                    queue[ql++] = item;\n                }\n            }\n        }\n    \n        // there are unmatched or invalid token pending from stack\n        if (stack) {\n            throw new Error(\"Invalid token found \" + stack[2][1]);\n        }\n        \n        return queue;\n    \n    }\n\nexport default parse;","'use strict';\n\nfunction empty() {}\n\nexport\n    function clone(instance) {\n        empty.prototype = instance;\n        return new empty();\n    }\n","'use strict';\n\nimport { clone } from \"./helper.js\";\n\n\nfunction Fragment(builder, pointer) {\n    this.id = 'f' + (++builder.fgen);\n    this.state = { id: null };\n    this.builder = builder;\n    \n    if (pointer) {\n        \n        this.pointer = pointer;\n        \n        for (; pointer.next; pointer = pointer.next) {}\n        this.lastPointer = pointer;\n        \n        // create outgoing\n        this.outgoing = this.lastOutgoing = {\n            fragment: this,\n            next: null\n        };\n        \n    }\n    \n    \n}\n\nFragment.prototype = {\n    constructor: Fragment,\n    id: null,\n    state: null,\n    base: null,\n    map: null,\n    splitted: null,\n    repeated: null,\n    pointer: null,\n    lastPointer: null,\n    outgoing: null,\n    lastOutgoing: null,\n    \n    link: function (operand2) {\n        var operand1 = this,\n            outgoing = operand1.outgoing,\n            split = operand1.splitted,\n            newSplit = operand2.splitted,\n            repeat = operand1.repeated;\n        var clone, last, fragment, pointer, startSplit, endSplit, created;\n        \n        operand2.applyState();\n        \n        for (; outgoing; outgoing = outgoing.next) {\n            outgoing.fragment.pointer.point(operand2);\n        }\n        \n        // repeat\n        if (repeat) {\n            last = operand2.lastPointer;\n            \n            for (; repeat; repeat = repeat.next) {\n                clone = repeat.pointer;\n                \n                if (!last) {\n                    operand2.pointer = clone;\n                }\n                else {\n                    last.next = clone;\n                }\n                \n                last = clone;\n                \n            }\n            \n            operand2.lastPointer = last;\n        }\n        \n        // split and not end state\n        pointer = operand2.pointer;\n        if (split && pointer) {\n            \n            startSplit = endSplit = null;\n            \n            // not end state\n            for (; split; split = split.next) {\n                fragment = split.fragment;\n                clone = pointer.clone();\n                last = fragment.lastPointer.last();\n                last.next = clone[0];\n                fragment.lastPointer = clone[1];\n                \n                // include split to next\n                if (fragment.pointer !== operand1.pointer) {\n                    created = {\n                        fragment: fragment,\n                        next: null\n                    };\n                    \n                    if (!startSplit) {\n                        startSplit = created;\n                    }\n                    else {\n                        endSplit.next = created;\n                    }\n                    \n                    endSplit = created;\n                }\n            }\n            \n            // concatenate split\n            if (endSplit) {\n                endSplit.next = newSplit;\n                newSplit = startSplit;\n            }\n\n        }\n        \n        // apply repeat to all splits?\n        \n        fragment = operand1.clone();\n        fragment.splitted = newSplit;\n        fragment.repeated = operand2.repeated;\n        \n        fragment.outgoing = operand2.outgoing;\n        fragment.lastOutgoing = operand2.lastOutgoing;\n        \n        return fragment;\n    },\n    \n    lastSplit: function () {\n        var split = this.splitted;\n        if (split) {\n            for (; split.next; split = split.next) {}\n            return split;\n        }\n        return null;\n        \n    },\n    \n    clone: function () {\n        var base = this.base,\n            cloned = clone(this);\n        \n        if (!base) {\n            cloned.base = this;\n        }\n        \n        cloned.id = 'f' + (++this.builder.fgen);\n        return cloned;\n    },\n    \n    split: function (repeat) {\n        var me = this,\n            current = me.splitted,\n            split = {\n                fragment: me,\n                next: null\n            },\n            fragment = me.clone();\n            \n        if (repeat) {\n            fragment.repeat();\n        }\n        \n        if (!current) {\n            fragment.splitted = split;\n        }\n        \n        return fragment;\n        \n    },\n    \n    repeat: function () {\n        var fragment = this,\n            pointer = fragment.pointer,\n            current = fragment.repeated;\n            \n        if (!current && pointer) {\n            pointer = pointer.clone();\n            \n            fragment.repeated = {\n                pointer: pointer[0],\n                next: null\n            };\n        }\n        \n        return fragment;\n    },\n    \n    fill: function (operand2) {\n        var operand1 = this,\n            range = operand1.pointer.range(operand2.pointer);\n        var fragment;\n            \n        if (range) {\n            \n            // set 2nd operand state id\n            operand2.state = operand1.state;\n            \n            // connect pointers\n            if (range) {\n                range[1].next = operand2.pointer;\n            }\n            else {\n                range = [operand2.pointer];\n            }\n            \n            operand1.lastPointer.next = range[0];\n            \n            fragment = operand1.clone();\n            fragment.lastPointer = operand2.lastPointer;\n            \n            // merge outgoing\n            fragment.outgoing.next = operand2.outgoing;\n            fragment.lastOutgoing = operand2.lastOutgoing;\n            \n            return fragment;\n        }\n        \n        // merge\n        return this.merge(operand2);\n    },\n    \n    merge: function (operand2) {\n        var operand1 = this,\n            fragment = operand1.clone();\n        var last, first, item;\n        \n        // apply state if operand1 has state\n        \n        // merge state\n        operand2.state = operand1.state;\n        \n        operand1.lastPointer.next = operand2.pointer;\n        operand1.lastOutgoing.next = operand2.outgoing;\n        \n        fragment.lastPointer = operand2.lastPointer;\n        fragment.lastOutgoing = operand2.lastOutgoing;\n        \n        // create split\n        first = operand1.splitted;\n        last = operand2.splitted;\n        fragment.splitted = first || last;\n        \n        if (first && last) {\n            for (item = first; item.next; item = item.next) { }\n            item.next = last;\n        }\n        \n        // create repeat\n        first = operand1.repeated;\n        last = operand2.repeated;\n        fragment.repeated = first || last;\n        \n        if (first && last) {\n            for (item = first; item.next; item = item.next) { }\n            item.next = last;\n        }\n        \n        \n        \n        return fragment;\n    },\n    \n    applyState: function () {\n        var state = this.state;\n        \n        if (!state.id) {\n            state.id = 's' + (++this.builder.gen);\n        }\n        \n        return state;\n    }\n    \n};\n\nexport default Fragment;\n","'use strict';\n\nimport {\n            assign\n        } from \"libcore\";\n        \nimport { clone } from \"./helper.js\";\n\n\nfunction Pointer(chr, negative) {\n    if (chr) {\n        this.chr = chr;\n    }\n    \n    this.negative = negative === true;\n}\n\nPointer.prototype = {\n    constructor: Pointer,\n    negative: false,\n    repeated: false,\n    chr: '',\n    to: null,\n    next: null,\n    \n    clone: function (overrides) {\n        var pointer = this,\n            from = null,\n            dupe = clone,\n            apply = assign,\n            includeNext = overrides !== false;\n        var created, last;\n        \n        if (!overrides) {\n            overrides = null;\n        }\n        \n        for (; pointer; pointer = pointer.next) {\n            created = dupe(pointer);\n            if (overrides) {\n                apply(created, overrides);\n            }\n            \n            if (from) {\n                last.next = created;\n            }\n            else {\n                from = created;\n            }\n            \n            last = created;\n            if (!includeNext) {\n                break;\n            }\n        }\n        \n        last.next = null;\n        \n        return [from, last];\n        \n    },\n    \n    point: function (fragment) {\n        var pointer = this;\n        \n        for (; pointer; pointer = pointer.next) {\n            if (!pointer.to) {\n                pointer.to = fragment;\n            }\n        }\n        \n        return this;\n    },\n    \n    last: function () {\n        var pointer = this;\n        \n        for (; pointer.next; pointer = pointer.next) {}\n        \n        return pointer;\n    },\n    \n    range: function (to) {\n        var chr = this.chr,\n            Class = Pointer,\n            S = String,\n            start = null,\n            end = null,\n            negative = this.negative;\n        var from, len, created;\n        \n        from = chr.charCodeAt(0);\n        chr = to.chr;\n        to = chr.charCodeAt(0);\n        len = Math.max(to - from - 1, 0);\n        \n        if (len) {\n            for (; len--;) {\n                created = new Class(S.fromCharCode(++from), negative);\n                if (start) {\n                    end.next = created;\n                }\n                else {\n                    start = created;\n                }\n                end = created;\n            }\n            \n            return start && [start, end];\n        \n        }\n        \n        return null;\n        \n    }\n    \n};\n\nexport default Pointer;","'use strict';\n\nimport parse from \"./parser.js\";\n\nimport StateMap from \"./state-map.js\";\n\nimport Fragment from \"./fragment.js\";\n\nimport Pointer from \"./pointer.js\";\n\nvar PATTERN_ERROR = 'Patterns resulting to empty token is not allowed. ';\n\nfunction build(name, regex, stateObject) {\n    \n    var F = Fragment,\n        P = Pointer,\n        rpn = parse(regex),\n        c = -1,\n        l = rpn.length,\n        stack = null,\n        startState = null,\n        el = 0,\n        endStates = [],\n        errorName = name + ' = /' + regex + '/',\n        builder = {\n            gen: 0,\n            fgen: 0\n        };\n        \n    var item, token, split, operand1, operand2, id, sid;\n        \n    if (!(stateObject instanceof StateMap)) {\n        stateObject = new StateMap();\n    }\n\n    for (; l--;) {\n        item = rpn[++c];\n        token = item[0];\n        \n        switch (token) {\n        // concat\n        case '.':\n            stack = [stack[0][0],\n                        stack[0][1].link(stack[1])];\n            break;\n        \n        // one or none\n        case '?':\n            stack = [stack[0],\n                        stack[1].split()];\n            break;\n        \n        // repeat one or more\n        case '+':\n            stack = [stack[0],\n                        stack[1].repeat()];\n            break;\n        \n        // repeat none or more (kleen star)\n        case '*':\n            stack = [stack[0],\n                        stack[1].split(true)];\n            break;\n        \n        // character class concat\n        case '^,':\n        case ',':\n        case '|': // also applicable to alternative\n            stack = [stack[0][0],\n                        stack[0][1].merge(stack[1],\n                                          token === '^,')];\n            break;\n        \n        // character class range\n        case '^-':\n        case '-':\n            stack = [stack[0][0],\n                        stack[0][1].fill(stack[1],\n                                         token === '^-')];\n            break;\n        \n        case '$$':\n            if (!stack || stack[0] !== null) {\n                console.warn(stack);\n                throw new Error(\"Invalid end of expression. \" + errorName);\n            }\n            \n            operand1 = stack[1];\n            operand2 = new F(builder, null);\n            operand1.link(operand2);\n            \n            sid = startState.id;\n            id = operand2.state.id;\n            \n            if (id === sid) {\n                throw new Error(PATTERN_ERROR + errorName);\n            }\n            \n            endStates[el++] = id;\n            \n            // end split fragments\n            split = operand1.splitted;\n            \n            for (; split; split = split.next) {\n                id = split.fragment.state.id;\n                if (id === sid) {\n                    throw new Error(PATTERN_ERROR + errorName);\n                }\n                endStates[el++] = id;\n                //if (id !== sid) {\n                //    console.log(regex);\n                //    endStates[el++] = id;\n                //}\n            }\n            break;\n        \n        case '^':\n        case '$':\n        case 'char':\n        case 'negative_char':\n            operand1 = new F(builder,\n                             new P(item[1], token === 'negative_char'));\n            \n            if (!startState) {\n                startState = operand1.applyState();\n            }\n\n            stack = [stack, operand1];\n            \n            \n\n        }\n        \n    }\n    \n    \n    if (el) {\n        stateObject.finalizeFragments(name, stack[1], endStates);\n    }\n    \n    builder = stack = split = operand1 = operand2 = null;\n    \n    return stateObject;\n    \n}\n\nexport default build;","'use strict';\n\nimport {\n            string,\n            regex,\n            array\n        } from \"libcore\";\n\nimport StateMap from \"./regex/state-map.js\";\n\nimport builder from \"./regex/state-builder.js\";\n\nfunction Tokenizer() {\n    this.map = new StateMap();\n}\n\nTokenizer.prototype = {\n    map: null,\n    constructor: Tokenizer,\n    \n    define: function (definitions) {\n        var isString = string,\n            isRegex = regex,\n            map = this.map,\n            priority = map.priority,\n            pl = priority.length,\n            build = builder,\n            name = null;\n        var item, c, len;\n        \n        if (!array(definitions)) {\n            throw new Error(\"Invalid definitions parameter.\");\n        }\n        \n        c = -1;\n        len = definitions.length;\n        \n        for (; len--;) {\n            item = definitions[++c];\n            \n            if (isString(item)) {\n                name = item;\n                \n            }\n            else if (isRegex(item)) {\n                item = item.source;\n                if (!name) {\n                    throw new Error(\"Token is not named \" + item);\n                }\n\n                // add priority\n                if (priority.indexOf(name) === -1) {\n                    priority[pl++] = name;\n                }\n                build(name, item, map);\n                \n            }\n            \n        }\n        \n        return this;\n    },\n    \n    fromJSON: function (data) {\n        this.map.importDefinition(data);\n        return this;\n    },\n    \n    toJSON: function () {\n        return JSON.stringify(this.toObject());\n    },\n    \n    toObject: function () {\n        return this.map.exportDefinition();\n    },\n    \n    tokenize: function (from, str) {\n        var map = this.map,\n            ends = map.ends,\n            states = map.states,\n            rank = map.priority,\n            cursor = [map.start, null],\n            len = str.length,\n            limit = len - from,\n            index = from - 1,\n            found = null,\n            lastFound = found,\n            charIndex = 0;\n        var chr, c, l, next, list, state, pointer, target, not, nmap, priority;\n        \n        if (limit === 0) {\n            return ['$', '', len + 1];\n        }\n        else if (limit < 1) {\n            return null;\n        }\n        \n        for (; limit--;) {\n            chr = str.charAt(++index);\n            next = null;\n\n            charIndex++;\n\n            for (; cursor; cursor = cursor[1]) {\n                state = cursor[0];\n                pointer = states[state];\n                \n                if (state in ends) {\n                    found = [ends[state], index, found];\n                }\n                \n                // apply positive match\n                if (chr in pointer) {\n                    list = pointer[chr];\n                    \n                    \n                    for (c = -1, l = list.length; l--;) {\n                        target = list[++c];\n                        next = [target, next];\n                        \n                        //console.log(state,':', chr, '->', target);\n                        \n                        // found token\n                        if (target in ends) {\n                            found = [ends[target], index + 1, found];\n                        }\n                    }\n                }\n                \n                // find negative match\n                not = pointer.not;\n                for (c = -1, l = not.length; l--;) {\n                    target = not[++c];\n                    nmap = target[1];\n                    \n                    if (!(chr in nmap)) {\n                        target = target[0];\n                        next = [target, next];\n                        //console.log(state,':', chr, '->', target);\n                        \n                        // found token\n                        if (target in ends) {\n                            found = [ends[target], index + 1, found];\n                        }\n                    }\n                }\n\n            }\n\n            // save last found \n            if (found) {\n                lastFound = found;\n            }\n\n            found = null;\n            \n            if (next) {\n                cursor = next;\n            }\n            else {\n                break;\n            }\n            \n        }\n\n        // resolve highest priority\n        for (pointer = lastFound; pointer; pointer = pointer[2]) {\n            index = pointer[1];\n            priority = rank.indexOf(pointer[0]);\n\n            // replace if high index and lowest priority\n            if (!found || index > found[1] || priority < found[2]) {\n                found = [pointer[0], index, priority];\n            }\n            \n        }\n        \n        if (found) {\n            \n            index = found[1];\n            \n            // nothing was parsed\n            if (from === index) {\n                found = null;\n            }\n            else {\n                found[2] = index;\n                found[1] = str.substring(from, index);\n            }\n        }\n        \n        return found;\n        \n    }\n};\n\n\nexport default Tokenizer;\n"],"names":["StateMap","start","states","not","this","priority","stateGenId","ends","escape","index","regexString","match","l","c","len","special","SPECIAL_CHAR","chr","substring","HEX_RE","String","fromCharCode","parseInt","UTF8_RE","range","length","charAt","RANGE_RE","test","tokenize","next","token","M","Math","max","Error","min","parse","str","item","op","stackOp","precedence","fill","opName","from","currentEnclosure","replacements","operator","OPERATOR","TOKENIZE","enclosed_start","ENCLOSED_START","enclosed_end","ENCLOSED_END","binary","BINARY","postfix","POSTFIX","end","FINAL","stack","queue","ql","lastToken","enclosure","enclosedReplacements","ENCLOSED_REPLACE","buffer","bl","bc","binaryCompare","empty","clone","instance","prototype","Fragment","builder","pointer","id","fgen","state","lastPointer","outgoing","lastOutgoing","fragment","Pointer","negative","build","name","regex","stateObject","split","operand1","operand2","sid","F","P","rpn","startState","el","endStates","errorName","gen","link","repeat","merge","console","warn","PATTERN_ERROR","splitted","applyState","finalizeFragments","Tokenizer","map","constructor","generateState","string","to","list","tl","targets","total","notIndex","processed","idmap","pending","pl","splice","indexOf","importDefinition","json","isObject","object","isString","JSON","e","number","array","exportDefinition","b","f","n","r","t","v","\\","B","[","[^","]","]^","(",")","?","+","*","-","^-","^,",",",".","|","$$","ENCLOSED_CLASS_REPLACE","base","repeated","last","startSplit","endSplit","created","newSplit","point","lastSplit","cloned","me","current","first","overrides","dupe","apply","assign","includeNext","Class","S","charCodeAt","define","definitions","isRegex","source","fromJSON","data","toJSON","stringify","toObject","target","rank","cursor","limit","found","lastFound","charIndex"],"mappings":"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"}